<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-10-18 Fri 00:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Informed/Heuristic Search</title>
<meta name="author" content="Arnav Gupta" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="src/latex.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Informed/Heuristic Search</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5dc1df8">1. Heuristic Search</a>
<ul>
<li><a href="#org59359f8">1.1. Greedy Best-First Search</a>
<ul>
<li><a href="#orgd134de2">1.1.1. Properties of GBFS</a></li>
</ul>
</li>
<li><a href="#org344ac85">1.2. Heuristic Depth-First Search</a></li>
</ul>
</li>
<li><a href="#orga1ba695">2. A* Search</a>
<ul>
<li><a href="#org58150c9">2.1. Admissibility of A*</a>
<ul>
<li><a href="#org5c7157b">2.1.1. Dominating Heuristic</a></li>
</ul>
</li>
<li><a href="#org832fb5d">2.2. Properties of A* Search</a></li>
<li><a href="#org9053c75">2.3. Multi-Path Pruning and A*</a></li>
</ul>
</li>
<li><a href="#org4294200">3. Adversarial Search</a>
<ul>
<li><a href="#org0f56682">3.1. Bidirectional Search</a></li>
<li><a href="#org2fc0e5e">3.2. Island Driven Search</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5dc1df8" class="outline-2">
<h2 id="org5dc1df8"><span class="section-number-2">1.</span> Heuristic Search</h2>
<div class="outline-text-2" id="text-1">
<p>
Use <b>heuristics</b> to guide the search towards the goals.
\(h(n)\) is an estimate of the cost of the shortest path from node \(n\) to a goal node.
Computing the heuristic must be much easier than solving the problem.
</p>

<p>
\(h(n)\) is an <b>underestimate</b> if there is no path from \(n\) to a goal that has path length
less than \(h(n)\).
</p>
</div>
<div id="outline-container-org59359f8" class="outline-3">
<h3 id="org59359f8"><span class="section-number-3">1.1.</span> Greedy Best-First Search</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Select the path whose end is closest to a goal according to the heuristic function, that is minimal
\(h\) value.
Treat the frontier as a priority queue ordered by \(h\).
</p>
</div>
<div id="outline-container-orgd134de2" class="outline-4">
<h4 id="orgd134de2"><span class="section-number-4">1.1.1.</span> Properties of GBFS</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Properties:
</p>
<ul class="org-ul">
<li><i>space complexity</i>: exponential</li>
<li><i>time complexity</i>: exponential</li>
<li><i>completeness</i>: no, could be stuck in a cycle</li>
<li><i>optimality</i>: no, may return sub-optimal path first</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org344ac85" class="outline-3">
<h3 id="org344ac85"><span class="section-number-3">1.2.</span> Heuristic Depth-First Search</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Do a DFS but add paths to the stack ordered by \(h\).
</p>

<p>
Same properties as DFS.
</p>
</div>
</div>
</div>
<div id="outline-container-orga1ba695" class="outline-2">
<h2 id="orga1ba695"><span class="section-number-2">2.</span> A* Search</h2>
<div class="outline-text-2" id="text-2">
<p>
Use both path cost and heuristics.
The sum of the path cost and heuristic from the end of the path to the goal is the <b>total path cost</b>.
</p>

<p>
Treats the frontier as a priority queue ordered by this sum.
Always selects the node on the frontier with the lowest estimated distance from the start to a goal node
constrained to go via that node.
</p>
</div>
<div id="outline-container-org58150c9" class="outline-3">
<h3 id="org58150c9"><span class="section-number-3">2.1.</span> Admissibility of A*</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A* always finds an optimal solution as the first path to the goal, if:
</p>
<ul class="org-ul">
<li>the branching factor is finite</li>
<li>arc costs are bounded above 0</li>
<li>\(h(n)\) is a lower bound on the cost of the shortest path from \(n\) to a goal node</li>
</ul>

<p>
<b>Admissible</b> heuristics never overestimate the cost to the goal.
</p>

<p>
A* halts since the cost of the paths on the frontier keeps increasing and will eventually exceed
any finite number.
</p>

<p>
To construct an admissible heuristic:
</p>
<ol class="org-ol">
<li>define a relaxed problem by simplifying or removing constraints on the original problem</li>
<li>solve the relaxed problem without search</li>
<li>the cost of the optimal solution to the relaxed problem is an admissible heuristic for the the
original problem</li>
</ol>

<p>
Preferred heuristics have higher values and are very different for different states (should help in
choosing which path to take).
</p>
</div>
<div id="outline-container-org5c7157b" class="outline-4">
<h4 id="org5c7157b"><span class="section-number-4">2.1.1.</span> Dominating Heuristic</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Given heuristics \(h_{1}(n)\) and \(h_{2}(n)\), \(h_{2}(n)\) dominates \(h_{1}(n)\) if:
</p>
<ul class="org-ul">
<li>\(\forall n \; h_{2}(n) \ge h_{1} (n)\)</li>
<li>\(\exists n \; h_{2}(n) > h_{1} (n)\)</li>
</ul>

<p>
If \(h_{2}(n)\) dominates \(h_{1}(n)\), A* using \(h_{2}\) will never expand more nodes than A* using
\(h_{1}(n)\).
</p>
</div>
</div>
</div>
<div id="outline-container-org832fb5d" class="outline-3">
<h3 id="org832fb5d"><span class="section-number-3">2.2.</span> Properties of A* Search</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Properties:
</p>
<ul class="org-ul">
<li><i>space complexity</i>: exponential</li>
<li><i>time complexity</i>: exponential</li>
<li><i>completeness</i>: yes, with above assumptions</li>
<li><i>optimality</i>: yes, with above assumptions</li>
</ul>

<p>
A* is optimally efficient: no other algorithm with the same start node and same heuristic can find the
optimal path to the goal and expand fewer nodes.
This is because any algorithm that does not expand all nodes \(f(n) < \text{cost}(s,g)\) run the risk
of missing the optimal solution.
</p>
</div>
</div>
<div id="outline-container-org9053c75" class="outline-3">
<h3 id="org9053c75"><span class="section-number-3">2.3.</span> Multi-Path Pruning and A*</h3>
<div class="outline-text-3" id="text-2-3">
<p>
With A*, it is possible that a subsequent path to some node is shorter than the first path to it.
To avoid this, ensure the heuristic is monotone.
</p>

<p>
A heuristic \(h\) is <b>monotone</b> is \(h(m) - h(n) \le \text{cost} (m, n)\) for every arc
\(\left< m, n \right>\).
This ensures the heuristic estimate of the path cost between any two adjacent nodes
is always less than the actual cost.
</p>

<p>
If \(h\) satisfies the monotone restriction, A* with multi-path pruning always finds the shortest path
to a goal.
</p>
</div>
</div>
</div>
<div id="outline-container-org4294200" class="outline-2">
<h2 id="org4294200"><span class="section-number-2">3.</span> Adversarial Search</h2>
<div class="outline-text-2" id="text-3">
<p>
Find the best option for the player on the nodes they control (MAX nodes).
Assume competitor takes options worst for the player (MIN nodes).
Recursively search to leaf nodes to find state evaluations and percolate values upward through the
tree.
</p>

<p>
<b>Alpha-beta pruning</b>: method that allows ignoring portions of the search tree without losing optimality
(useful in practice but does not change worst-case)
</p>

<p>
Can stop search early at non-leaf nodes via heuristics, but optimality no longer guaranteed.
</p>
</div>
<div id="outline-container-org0f56682" class="outline-3">
<h3 id="org0f56682"><span class="section-number-3">3.1.</span> Bidirectional Search</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Searching is <b>symmetric</b>: it is the same to find path from start nodes to goal node or goal node
to start node.
</p>

<p>
<b>Forward branching factor</b>: number of arcs out of a node
</p>

<p>
<b>Backward branching factor</b>: number of arcs into a node
</p>

<p>
Search complexity is \(b^{n}\), so should use forward search if forward branching factor is less
than backward branching factor. (not possible if graph is dynamically constructed)
</p>

<p>
Can search simultaneously backwards from goal and forward from start, which can result exponential
saving in time/space.
</p>

<p>
In bidirectional search, frontiers must meet.
Often done with one breadth-first method that builds a set of locations to the goal and
the other direction using another method to find paths to these locations.
</p>
</div>
</div>
<div id="outline-container-org2fc0e5e" class="outline-3">
<h3 id="org2fc0e5e"><span class="section-number-3">3.2.</span> Island Driven Search</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Find a set of islands between the start and goal, which gives smaller problems to solve.
</p>

<p>
This reduces the time complexity to \(mb^{k/m}\) when \(m-1\) islands are used (\(m\) smaller problems to solve).
</p>

<p>
Difficult to guarantee optimality when identifying islands the path must pass through.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Arnav Gupta</p>
<p class="date">Created: 2024-10-18 Fri 00:37</p>
</div>
</body>
</html>
