<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-04 Mon 01:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Locks</title>
<meta name="author" content="Arnav Gupta" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="src/latex.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Locks</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5d4261c">1. Lock Taxonomy</a></li>
<li><a href="#org1bf19e1">2. Spin Lock</a>
<ul>
<li><a href="#org11643a6">2.1. Implementation</a></li>
</ul>
</li>
<li><a href="#orgc008d81">3. Blocking Locks</a>
<ul>
<li><a href="#org7b1366f">3.1. Mutex Lock</a>
<ul>
<li><a href="#org434a19f">3.1.1. Implementation</a></li>
<li><a href="#org1dcf405">3.1.2. uOwnerLock</a></li>
<li><a href="#org1cad003">3.1.3. Stream Locks</a></li>
</ul>
</li>
<li><a href="#org02b2ce8">3.2. Synchronization Lock</a>
<ul>
<li><a href="#org17ec645">3.2.1. Implementation</a></li>
<li><a href="#orgafd98b3">3.2.2. uCondLock</a></li>
<li><a href="#orga58f0e8">3.2.3. Programming Pattern</a></li>
</ul>
</li>
<li><a href="#orga1f0b87">3.3. Barrier</a>
<ul>
<li><a href="#org6a8966c">3.3.1. Fetch Increment Barrier</a></li>
<li><a href="#org7ec871f">3.3.2. uBarrier</a></li>
</ul>
</li>
<li><a href="#org9d1f28d">3.4. Binary Semaphore</a>
<ul>
<li><a href="#org1806d77">3.4.1. Implementation</a></li>
</ul>
</li>
<li><a href="#org7c119d5">3.5. Counting Semaphore</a>
<ul>
<li><a href="#org130251d">3.5.1. Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org004a3e6">4. Lock Programming</a>
<ul>
<li><a href="#orgbd12839">4.1. Precedence Graph</a></li>
<li><a href="#orgf2d016b">4.2. Buffering</a>
<ul>
<li><a href="#orgc751fbb">4.2.1. Unbounded Buffer</a></li>
<li><a href="#org3b117b6">4.2.2. Bounded Buffer</a></li>
</ul>
</li>
<li><a href="#org692d264">4.3. Lock Techniques</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org5d4261c" class="outline-2">
<h2 id="org5d4261c"><span class="section-number-2">1.</span> Lock Taxonomy</h2>
<div class="outline-text-2" id="text-1">
<p>
Locks can be either spinning or blocking.
</p>

<p>
<b>Spinning locks</b> busy wait until an event occurs, so the task oscillates between ready and running
due to time slicing (can also optionally yield).
</p>

<p>
<b>Blocking locks</b> do not busy wait but block until an event occurs, so some other mechanism must
unblock the waiting task when the event happens.
</p>
</div>
</div>
<div id="outline-container-org1bf19e1" class="outline-2">
<h2 id="org1bf19e1"><span class="section-number-2">2.</span> Spin Lock</h2>
<div class="outline-text-2" id="text-2">
<p>
When a task is busy waiting, it usually loops until the critical section is unlocked or
it is preempted and placed on the ready queue.
</p>

<p>
To increase uniprocessor efficiency, a task can:
</p>
<ul class="org-ul">
<li>explicitly terminate its time slice</li>
<li>move back to the ready state after only one event check fails</li>
</ul>

<p>
<code>yield</code> relinquishes the time-slice by rescheduling the running task back onto the ready
queue.
To increase multiprocessor efficiency, a task can yield after \(N\) event checks fail.
</p>

<p>
<b>Adaptive Spin Lock</b>: allow adjustment of spin duration
</p>

<p>
Most spin-lock implementations can cause starvation of 1+ tasks.
</p>

<p>
Spin lock is appropriate and necessary in situations where this is no other work to do.
</p>
</div>
<div id="outline-container-org11643a6" class="outline-3">
<h3 id="org11643a6"><span class="section-number-3">2.1.</span> Implementation</h3>
<div class="outline-text-3" id="text-2-1">
<p>
&mu;C++ provides <code>uSpinLock</code> (non-yielding) and <code>uLock</code> (yielding)
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">uSpinLock</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span>:
        uSpinLock<span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">open</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">()</span>;
        <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">tryacquire</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">makes only 1 attempt to acquire lock</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">uLock</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">uLock</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">value</span> = <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #c678dd;">)</span>;
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">()</span>;
        <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">tryacquire</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">makes only 1 attempt to acquire lock</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Locks built from atomic hardware instructions.
Locks start closed (0) or opened (1).
</p>

<p>
Starvation can occur in theory, but rare in practice.
</p>

<p>
Cannot assign to or copy a lock, must use as reference/pointer.
Can be used for synchronization or mutual exclusion.
</p>
</div>
</div>
</div>
<div id="outline-container-orgc008d81" class="outline-2">
<h2 id="orgc008d81"><span class="section-number-2">3.</span> Blocking Locks</h2>
<div class="outline-text-2" id="text-3">
<p>
For blocking locks, the acquiring task is not the only one responsible for detecting an
open lock:
</p>
<ul class="org-ul">
<li>acquiring task makes 1 check for open lock and then blocks</li>
<li>releasing task is responsible for detecting a blocked acquirer and transferring or
releasing the lock</li>
</ul>

<p>
Blocking locks reduce busy waiting through <b>cooperation</b>.
</p>

<p>
All blocking locks have
</p>
<ul class="org-ul">
<li>state to facilitate lock semantics</li>
<li>list of blocked acquirers</li>
</ul>
</div>
<div id="outline-container-org7b1366f" class="outline-3">
<h3 id="org7b1366f"><span class="section-number-3">3.1.</span> Mutex Lock</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Used solely to provide mutual exclusion:
</p>
<ul class="org-ul">
<li>separates lock usage between synchronization and mutual exclusion</li>
<li>permits optimizations and checks as the lock only provides one specialized function</li>
</ul>

<p>
Mutex locks can be <b>single acquisition</b> (acquirer cannot acquire again) or
<b>multiple acquisition</b> (acquirer can acquire multiple times).
Multiple acquisition locks are called <b>owner locks</b>.
</p>

<p>
Owner locks can handle looping/recursion and may require 1 release or as many
as it requires.
</p>
</div>
<div id="outline-container-org434a19f" class="outline-4">
<h4 id="org434a19f"><span class="section-number-4">3.1.1.</span> Implementation</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">MutexLock</span> <span style="color: #51afef;">{</span>
        <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">avail</span>;
        <span style="color: #ECBE7B;">Task</span> * <span style="color: #dcaeea;">owner</span>;
        <span style="color: #ECBE7B;">queue</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">Task</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">blocked</span>;
        <span style="color: #ECBE7B;">SpinLock</span> <span style="color: #dcaeea;">lock</span>;
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">MutexLock</span><span style="color: #c678dd;">()</span> : avail <span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">true</span> <span style="color: #c678dd;">}</span>, owner<span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">nullptr</span> <span style="color: #c678dd;">}</span> <span style="color: #c678dd;">{}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            <span style="color: #51afef;">while</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>avail &amp;&amp; owner != currThread<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                yieldNoSchedule<span style="color: #a9a1e1;">(</span> lock <span style="color: #a9a1e1;">)</span>;
                lock.acquire<span style="color: #a9a1e1;">()</span>;
            <span style="color: #98be65;">}</span>
            avail = <span style="color: #a9a1e1;">false</span>;
            owner = currThread<span style="color: #98be65;">()</span>;
            lock.release<span style="color: #98be65;">()</span>;
        <span style="color: #c678dd;">}</span>

        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> owner != currThread<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">error check</span>
            <span style="color: #98be65;">}</span>
            owner = <span style="color: #a9a1e1;">nullptr</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>blocked.empty<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make ready</span>
            <span style="color: #98be65;">}</span>
            avail = <span style="color: #a9a1e1;">true</span>;
            lock.release<span style="color: #98be65;">()</span>;
        <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
<code>yieldNoSchedule</code> yields the processor time slice but does not reschedule thread to
the ready queue.
</p>

<p>
This code allows for barging since <code>avail</code> and the lock reset.
</p>

<p>
For <b>barging avoidance</b>, must hold <code>avail</code> between releasing and unblocking task
(protects against bounded overtaking):
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">MutexLock</span> <span style="color: #51afef;">{</span>
        <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">avail</span>;
        <span style="color: #ECBE7B;">Task</span> * <span style="color: #dcaeea;">owner</span>;
        <span style="color: #ECBE7B;">queue</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">Task</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">blocked</span>;
        <span style="color: #ECBE7B;">SpinLock</span> <span style="color: #dcaeea;">lock</span>;
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">MutexLock</span><span style="color: #c678dd;">()</span> : avail <span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">true</span> <span style="color: #c678dd;">}</span>, owner<span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">nullptr</span> <span style="color: #c678dd;">}</span> <span style="color: #c678dd;">{}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>avail &amp;&amp; owner != currThread<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                yieldNoSchedule<span style="color: #a9a1e1;">(</span> lock <span style="color: #a9a1e1;">)</span>;
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not reacquire lock since avail == false</span>
            <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
                avail = <span style="color: #a9a1e1;">false</span>;
                lock.release<span style="color: #a9a1e1;">()</span>;
            <span style="color: #98be65;">}</span>
            owner = currThread<span style="color: #98be65;">()</span>;
        <span style="color: #c678dd;">}</span>

        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            owner = <span style="color: #a9a1e1;">nullptr</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>blocked.empty<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make ready</span>
            <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
                avail = <span style="color: #a9a1e1;">true</span>;
            <span style="color: #98be65;">}</span>
            lock.release<span style="color: #98be65;">()</span>;
        <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
With these changes, bargers enter mutual exclusion protocol but block so the released
task does not busy wait.
This means mutual exclusion conceptually passed from releasing to unblocking tasks.
</p>

<p>
For <b>barging prevention</b>, must hold <code>lock</code> between releasing and unblocking task
(protects against unbounded overtaking):
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">MutexLock</span> <span style="color: #51afef;">{</span>
        <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">avail</span>;
        <span style="color: #ECBE7B;">Task</span> * <span style="color: #dcaeea;">owner</span>;
        <span style="color: #ECBE7B;">queue</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">Task</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">blocked</span>;
        <span style="color: #ECBE7B;">SpinLock</span> <span style="color: #dcaeea;">lock</span>;
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">MutexLock</span><span style="color: #c678dd;">()</span> : avail <span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">true</span> <span style="color: #c678dd;">}</span>, owner<span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">nullptr</span> <span style="color: #c678dd;">}</span> <span style="color: #c678dd;">{}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>avail &amp;&amp; owner != currThread<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                yieldNoSchedule<span style="color: #a9a1e1;">(</span> lock <span style="color: #a9a1e1;">)</span>;
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not reacquire lock</span>
            <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
                avail = <span style="color: #a9a1e1;">false</span>;
            <span style="color: #98be65;">}</span>
            owner = currThread<span style="color: #98be65;">()</span>;
            lock.release<span style="color: #98be65;">()</span>;
        <span style="color: #c678dd;">}</span>

        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            owner = <span style="color: #a9a1e1;">nullptr</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>blocked.empty<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make ready</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not release lock</span>
            <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
                avail = <span style="color: #a9a1e1;">true</span>;
                lock.release<span style="color: #a9a1e1;">()</span>;
            <span style="color: #98be65;">}</span>
        <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
The critical section is not bracketed by the spin lock when the lock is passed,
so this works.
</p>

<p>
An alternative would be to leave the lock owner at the front of the blocked list
to act as availability and owner variable.
If the critical section is acquired, the blocked list must have a node on it to check
if it is in use.
</p>
</div>
</div>
<div id="outline-container-org1dcf405" class="outline-4">
<h4 id="org1dcf405"><span class="section-number-4">3.1.2.</span> uOwnerLock</h4>
<div class="outline-text-4" id="text-3-1-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">uOwnerLock</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">uOwnerLock</span><span style="color: #c678dd;">()</span>;
        <span style="color: #ECBE7B;">uBaseTask</span> * <span style="color: #c678dd;">owner</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">nullptr if no owner, else owner address</span>
        <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">times</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">number of times lock has been acquired by owner</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">()</span>;
        <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">tryacquire</span><span style="color: #c678dd;">()</span>;
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Must release as many times as acquired.
</p>

<p>
Can use <code>_Finally</code> or RAII to ensure lock is always released.
However, this cannot be used for barging prevention.
</p>
</div>
</div>
<div id="outline-container-org1cad003" class="outline-4">
<h4 id="org1cad003"><span class="section-number-4">3.1.3.</span> Stream Locks</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
Can use <code>osacquire</code> for output streams and <code>isacquire</code> for input streams
to ensure predictable streams.
</p>
</div>
</div>
</div>
<div id="outline-container-org02b2ce8" class="outline-3">
<h3 id="org02b2ce8"><span class="section-number-3">3.2.</span> Synchronization Lock</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Used solely to block tasks waiting for synchronization.
</p>

<p>
Only state is a list of blocked tasks, so:
</p>
<ul class="org-ul">
<li>acquiring task always blocks (no state to make it conditional)</li>
<li>release is lost when no waiting task (no state to remember it)</li>
</ul>

<p>
Uses wait for acquire and signal for release.
</p>
</div>
<div id="outline-container-org17ec645" class="outline-4">
<h4 id="org17ec645"><span class="section-number-4">3.2.1.</span> Implementation</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Needs mutual exclusion for safe implementation.
</p>

<p>
Location of mutual exclusion classifies synchronization lock:
</p>
<ul class="org-ul">
<li><b>external lock</b>: use an external lock to protect task list</li>
<li><b>internal lock</b>: use an internal lock to protect state</li>
</ul>

<p>
With external locking:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SyncLock</span> <span style="color: #51afef;">{</span>
        <span style="color: #ECBE7B;">Task</span> * <span style="color: #dcaeea;">list</span>;
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">SyncLock</span><span style="color: #c678dd;">()</span> : list<span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">nullptr</span> <span style="color: #c678dd;">}</span> <span style="color: #c678dd;">{}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">MutexLock</span> &amp; <span style="color: #dcaeea;">m</span> <span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">add self to task list</span>
            yieldNoSchedule<span style="color: #98be65;">(</span> m <span style="color: #98be65;">)</span>;
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">possibly reacquire mutex lock</span>
        <span style="color: #c678dd;">}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> list != <span style="color: #a9a1e1;">nullptr</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make it ready</span>
            <span style="color: #98be65;">}</span>
        <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
Uses external task to avoid lost release and need mutual exclusion
to protect task list (and possible external state).
The releasing task detects a blocked task and performs necessary
cooperation.
</p>

<p>
To use with barging avoidance:
</p>
<div class="org-src-container">
<pre class="src src-cpp">m.acquire<span style="color: #51afef;">()</span>;
<span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>s.empty<span style="color: #c678dd;">()</span> <span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    s.release<span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
    occupied = <span style="color: #a9a1e1;">false</span>;
<span style="color: #51afef;">}</span>
m.release<span style="color: #51afef;">()</span>;
</pre>
</div>

<p>
To use with barging prevention:
</p>
<div class="org-src-container">
<pre class="src src-cpp">m.acquire<span style="color: #51afef;">()</span>;
<span style="color: #51afef;">if</span> <span style="color: #51afef;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>s.empty<span style="color: #c678dd;">()</span> <span style="color: #51afef;">)</span> <span style="color: #51afef;">{</span>
    s.release<span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span> <span style="color: #51afef;">else</span> <span style="color: #51afef;">{</span>
    occupied = <span style="color: #a9a1e1;">false</span>;
    m.release<span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
With internal locking:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">SyncLock</span> <span style="color: #51afef;">{</span>
        <span style="color: #ECBE7B;">Task</span> * <span style="color: #dcaeea;">list</span>;
        <span style="color: #ECBE7B;">SpinLock</span> <span style="color: #dcaeea;">lock</span>;
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">SyncLock</span><span style="color: #c678dd;">()</span> : list<span style="color: #c678dd;">{</span> <span style="color: #a9a1e1;">nullptr</span> <span style="color: #c678dd;">}</span> <span style="color: #c678dd;">{}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">acquire</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">MutexLock</span> &amp; <span style="color: #dcaeea;">m</span> <span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">add self to task list</span>
            m.release<span style="color: #98be65;">()</span>;
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">can be interrupted here, but fine since spin lock</span>
            yieldNoSchedule<span style="color: #98be65;">(</span> lock <span style="color: #98be65;">)</span>;
            m.acquire<span style="color: #98be65;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">possibly reacquire mutex lock</span>
        <span style="color: #c678dd;">}</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">release</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
            lock.acquire<span style="color: #98be65;">()</span>;
            <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> list != <span style="color: #a9a1e1;">nullptr</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make it ready</span>
            <span style="color: #98be65;">}</span>
            lock.release<span style="color: #98be65;">()</span>;
        <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
This still takes an external lock for barging avoidance/prevention.
</p>
</div>
</div>
<div id="outline-container-orgafd98b3" class="outline-4">
<h4 id="orgafd98b3"><span class="section-number-4">3.2.2.</span> uCondLock</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">uCondLock</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span>:
        <span style="color: #c678dd;">uCondLock</span><span style="color: #c678dd;">()</span>;
        <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">wait</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">uOwnerLock</span> &amp; <span style="color: #dcaeea;">lock</span> <span style="color: #c678dd;">)</span>;
        <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">signal</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unblocks in FIFO order</span>
        <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">broadcast</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">unblocks all waiting tasks</span>
        <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">empty</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">are blocked tasks on the queue?</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
<code>wait</code> atomically blocks the calling task and releases the argument owner lock,
and reacquires it before returning.
</p>

<p>
<code>signal</code> and <code>broadcast</code> do nothing for an empty conditional and return false,
otherwise return true.
</p>
</div>
</div>
<div id="outline-container-orga58f0e8" class="outline-4">
<h4 id="orga58f0e8"><span class="section-number-4">3.2.3.</span> Programming Pattern</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Must provide external mutual exclusion and protect against lost signal (release).
</p>

<p>
Should surround conditional lock with mutex lock.
</p>
</div>
</div>
</div>
<div id="outline-container-orga1f0b87" class="outline-3">
<h3 id="orga1f0b87"><span class="section-number-3">3.3.</span> Barrier</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Coordinates a group of tasks performing a concurrent operation surrounded by sequential
operations.
Meant for synchronization, not mutual exclusion.
</p>

<p>
Two kinds of barriers:
</p>
<ul class="org-ul">
<li>threads == group size</li>
<li>threads &gt; group size</li>
</ul>

<p>
Barrier retains state about the events it manages (num tasks blocked on the barrier).
Most barriers use internal locking.
</p>

<p>
Barrier blocks each task at call to <code>block</code> until all tasks have called <code>block</code>.
Last task to call <code>block</code> does not block, instead it releases all other tasks.
</p>

<p>
Must specify in advance number of <code>block</code> operations before tasks released.
</p>

<p>
Barriers are commonly used for synchronized one-shot and for synchronized start
and end in a cycle.
</p>

<p>
Using a barrier is cheaper than creating and deleting tasks for each computation.
</p>
</div>
<div id="outline-container-org6a8966c" class="outline-4">
<h4 id="org6a8966c"><span class="section-number-4">3.3.1.</span> Fetch Increment Barrier</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
A spinning, T == G barrier can be implemented with the fetch-increment instruction
and a flag that waiters wait on.
</p>
</div>
</div>
<div id="outline-container-org7ec871f" class="outline-4">
<h4 id="org7ec871f"><span class="section-number-4">3.3.2.</span> uBarrier</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
&mu;C++ barrier is a blocking, T &gt; G, barging-prevention coroutine, where <code>main</code>
can be resumed by the last task arriving at the barrier:
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #51afef;">&lt;</span><span style="color: #98be65;">uBarrier.h</span><span style="color: #51afef;">&gt;</span>
<span style="color: #ECBE7B;">_Cormonitor</span> <span style="color: #dcaeea;">uBarrier</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">protected</span>:
        <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">main</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> <span style="color: #51afef;">for</span> <span style="color: #98be65;">(</span> ;; <span style="color: #98be65;">)</span> suspend<span style="color: #98be65;">()</span>; <span style="color: #c678dd;">}</span>
        <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">last</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> resume<span style="color: #98be65;">()</span>; <span style="color: #c678dd;">}</span> <span style="color: #5B6268;">// </span><span style="color: #5B6268;">called by last task to barier</span>
    <span style="color: #51afef;">public</span>:
        uBarrier<span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">total</span> <span style="color: #c678dd;">)</span>;
        <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">total</span><span style="color: #c678dd;">()</span> <span style="color: #51afef;">const</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;"># of tasks synchronizing</span>
        <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">waiters</span><span style="color: #c678dd;">()</span> <span style="color: #51afef;">const</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;"># of waiting tasks</span>
        <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">reset</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> total <span style="color: #c678dd;">)</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">reset # of tasks synchronizing</span>
        <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">void</span> <span style="color: #dcaeea;">block</span><span style="color: #c678dd;">()</span>; <span style="color: #5B6268;">//</span><span style="color: #5B6268;">wait for Nth thread</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<p>
<code>uBarrier</code> has implicit mutual exclusion so no barging.
</p>

<p>
Can build a barrier by inheriting from <code>uBarrier</code>, redefining <code>last</code>, <code>block</code>,
and possibly <code>main</code>.
</p>

<p>
Coroutine barrier can be reused many times.
</p>
</div>
</div>
</div>
<div id="outline-container-org9d1f28d" class="outline-3">
<h3 id="org9d1f28d"><span class="section-number-3">3.4.</span> Binary Semaphore</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Blocking equivalent to a yielding spin-lock, providing synchronization and mutual exclusion.
</p>

<p>
Acquire is <code>P</code> (waits if counter is 0, then decrements).
Release is <code>V</code> (increases counter and unblocks waiting task if present).
</p>

<p>
Binary semaphore has only 2 states, open and closed.
</p>
</div>
<div id="outline-container-org1806d77" class="outline-4">
<h4 id="org1806d77"><span class="section-number-4">3.4.1.</span> Implementation</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Has a:
</p>
<ul class="org-ul">
<li>blocking task list</li>
<li><code>avail</code> &rarr; if event has occurred (state)</li>
<li>spin lock to protect state</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">BinSem</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">queue</span><span style="color: #c678dd;">&lt;</span>Task<span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">blocked</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">blocked tasks</span>
    <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">avail</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">resource available</span>
    <span style="color: #ECBE7B;">SpinLock</span> <span style="color: #dcaeea;">lock</span>;
<span style="color: #51afef;">public</span>:
    <span style="color: #c678dd;">BinSem</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">start</span> = <span style="color: #a9a1e1;">true</span> <span style="color: #c678dd;">)</span> : avail<span style="color: #c678dd;">(</span> start <span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{}</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">P</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
        lock.acquire<span style="color: #98be65;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">prevention barging</span>
        <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>avail <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">add self to blocked list</span>
            yieldNoSchedule<span style="color: #a9a1e1;">(</span> lock <span style="color: #a9a1e1;">)</span>;
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not reacquire lock</span>
        <span style="color: #98be65;">}</span>
        avail = <span style="color: #a9a1e1;">false</span>;
        lock.release<span style="color: #98be65;">()</span>;
    <span style="color: #c678dd;">}</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">V</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
        lock.acquire<span style="color: #98be65;">()</span>;
        <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> <span style="color: #51afef; font-weight: bold;">!</span>blocked.empty<span style="color: #a9a1e1;">()</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make ready</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not release lock</span>
        <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
            avail = <span style="color: #a9a1e1;">true</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">conditional reset</span>
            lock.release<span style="color: #a9a1e1;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">no race</span>
        <span style="color: #98be65;">}</span>
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>;
</pre>
</div>

<p>
Higher cost for synchronization if external lock already acquired.
</p>
</div>
</div>
</div>
<div id="outline-container-org7c119d5" class="outline-3">
<h3 id="org7c119d5"><span class="section-number-3">3.5.</span> Counting Semaphore</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Allow a multi-valued semaphore, which allows for critical sections allowing \(N\) simultaneous tasks.
</p>

<p>
Done by augmenting <code>V</code> to allow increasing the counter an arbitrary amount.
</p>
</div>
<div id="outline-container-org130251d" class="outline-4">
<h4 id="org130251d"><span class="section-number-4">3.5.1.</span> Implementation</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
Change availability into a counter, set to some maximum on creation.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">CntSem</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">queue</span><span style="color: #c678dd;">&lt;</span>Task<span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">blocked</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">blocked tasks</span>
    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">cnt</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">resource being used</span>
    <span style="color: #ECBE7B;">SpinLock</span> <span style="color: #dcaeea;">lock</span>;
<span style="color: #51afef;">public</span>:
    <span style="color: #c678dd;">CntSem</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">start</span> = <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #c678dd;">)</span> : cnt<span style="color: #c678dd;">(</span> start <span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{}</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">P</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
        lock.acquire<span style="color: #98be65;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">prevention barging</span>
        cnt -= <span style="color: #da8548; font-weight: bold;">1</span>;
        <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> cnt &lt; <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">add self to blocked list</span>
            yieldNoSchedule<span style="color: #a9a1e1;">(</span> lock <span style="color: #a9a1e1;">)</span>;
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not reacquire lock</span>
        <span style="color: #98be65;">}</span>
        lock.release<span style="color: #98be65;">()</span>;
    <span style="color: #c678dd;">}</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">V</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
        lock.acquire<span style="color: #98be65;">()</span>;
        cnt += <span style="color: #da8548; font-weight: bold;">1</span>;
        <span style="color: #51afef;">if</span> <span style="color: #98be65;">(</span> cnt &lt;= <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">remove task from blocked list and make ready</span>
            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">do not release lock</span>
        <span style="color: #98be65;">}</span> <span style="color: #51afef;">else</span> <span style="color: #98be65;">{</span>
            lock.release<span style="color: #a9a1e1;">()</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">no race</span>
        <span style="color: #98be65;">}</span>
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>;
</pre>
</div>

<p>
To use a semaphore:
</p>
<ul class="org-ul">
<li>for synchronization, semaphore at 0 &rarr; waiting for an event</li>
<li>for mutual exclusion, semaphore at \(N\) &rarr; controls a critical section</li>
</ul>

<p>
&mu;C++ has a counting semaphore, which subsumes a binary semaphore
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #51afef;">&lt;</span><span style="color: #98be65;">uSemaphore.h</span><span style="color: #51afef;">&gt;</span>
<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">uSemaphore</span> <span style="color: #51afef;">{</span>
<span style="color: #51afef;">public</span>:
    <span style="color: #c678dd;">uSemaphore</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">count</span> = <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">P</span><span style="color: #c678dd;">()</span>;
    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">TryP</span><span style="color: #c678dd;">()</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">V</span><span style="color: #c678dd;">(</span> <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">times</span> = <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">counter</span><span style="color: #c678dd;">()</span> <span style="color: #51afef;">const</span>;
    <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">empty</span><span style="color: #c678dd;">()</span> <span style="color: #51afef;">const</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">threads blocked?</span>
<span style="color: #51afef;">}</span>;
</pre>
</div>

<p>
<code>P</code> decrements the counter, if the counter is &ge; 0, the calling task continues, else it blocks.
</p>

<p>
<code>TryP</code> returns true if the semaphore is acquired and false otherwise (never blocks).
</p>

<p>
<code>V</code> wakes up the task blocked for the longest time and increments the counter, can occur \(N\) times.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org004a3e6" class="outline-2">
<h2 id="org004a3e6"><span class="section-number-2">4.</span> Lock Programming</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgbd12839" class="outline-3">
<h3 id="orgbd12839"><span class="section-number-3">4.1.</span> Precedence Graph</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Binary semaphore with <code>COBEGIN</code> are as powerful as <code>START</code> and <code>WAIT</code>.
</p>

<p>
Analyze which data and code depend on each other and display dependencies graphically
in a <b>precedence graph</b>.
</p>
</div>
</div>
<div id="outline-container-orgf2d016b" class="outline-3">
<h3 id="orgf2d016b"><span class="section-number-3">4.2.</span> Buffering</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Tasks communicate unidirectionally through a queue, with the producer adding items to the back
of the queue and the consumer removing items from the front of the queue.
</p>
</div>
<div id="outline-container-orgc751fbb" class="outline-4">
<h4 id="orgc751fbb"><span class="section-number-4">4.2.1.</span> Unbounded Buffer</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Two tasks communicate through a queue of unbounded length.
</p>

<p>
Since tasks work at different speeds, the producer may get ahead of the consumer.
Producer never has to wait (infinite length) but the consumer may have to wait for the producer to add.
</p>

<p>
This can be solved with a counting semaphore controlling access to the shared queue.
</p>
</div>
</div>
<div id="outline-container-org3b117b6" class="outline-4">
<h4 id="org3b117b6"><span class="section-number-4">4.2.2.</span> Bounded Buffer</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Two tasks communicate through a queue of bounded length.
</p>

<p>
Producer has to wait if buffer full, consumer has to wait if buffer empty.
</p>

<p>
This can be solved with an additional counting semaphore to keep track of if the buffer is empty.
</p>
</div>
</div>
</div>
<div id="outline-container-org692d264" class="outline-3">
<h3 id="org692d264"><span class="section-number-3">4.3.</span> Lock Techniques</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<b>Split binary semaphore</b>: collection of semaphores where at most 1 of the collection has the value 1
</p>
<ul class="org-ul">
<li>used when different kinds of tasks have to block separately</li>
<li>cannot differentiate tasks blocked on the same semaphore</li>
</ul>

<p>
Split binary semaphores can be used for <b>baton passing</b>:
</p>
<ul class="org-ul">
<li>there is exactly one conceptual baton</li>
<li>nobody moves in the entry/exit code unless they have the baton</li>
<li>once the baton is release, cannot read/write variables in entry/exit</li>
</ul>

<p>
Mutex/condition lock cannot perform baton passing to prevent barging if the signaled task
must implicitly reacquire the mutex lock before continuing, since the signaler must release
the mutex lock.
This causes a race between the signalled and calling tasks, resulting in barging.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Arnav Gupta</p>
<p class="date">Created: 2024-11-04 Mon 01:29</p>
</div>
</body>
</html>
