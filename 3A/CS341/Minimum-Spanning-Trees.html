<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-02-29 Thu 12:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Minimum Spanning Trees</title>
<meta name="author" content="Arnav Gupta" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Minimum Spanning Trees</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org252e9b8">1. Spanning Trees</a></li>
<li><a href="#org1e10be4">2. Kruskal&rsquo;s Algorithm</a>
<ul>
<li><a href="#orgabbd721">2.1. Augmenting Sets without Cycles</a></li>
<li><a href="#org1e2c9b6">2.2. Properties of the Output</a></li>
<li><a href="#org6203ecb">2.3. Exchanging Edges</a></li>
<li><a href="#orgef24e31">2.4. Correctness: Exchange Argument</a></li>
</ul>
</li>
<li><a href="#org8c1bdbd">3. Data Structures for Kruskal&rsquo;s Algorithm</a>
<ul>
<li><a href="#org13fcbd2">3.1. Implementation</a></li>
<li><a href="#org68dbc23">3.2. Linked List</a></li>
<li><a href="#org02ce4a6">3.3. Simple Heuristics for Union</a>
<ul>
<li><a href="#org0d1af98">3.3.1. Modified Union</a></li>
<li><a href="#orge8ead98">3.3.2. Key Observation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org252e9b8" class="outline-2">
<h2 id="org252e9b8"><span class="section-number-2">1.</span> Spanning Trees</h2>
<div class="outline-text-2" id="text-1">
<p>
For a connected graph \(G = (V, E)\), a spanning tree in \(G\) is a tree of the form \((V, A)\)
with \(A\) a subset of \(E\) (a tree with edges from \(E\) that covers all vertices).
</p>

<p>
The goal is to find a spanning tree with minimal weight.
</p>
</div>
</div>
<div id="outline-container-org1e10be4" class="outline-2">
<h2 id="org1e10be4"><span class="section-number-2">2.</span> Kruskal&rsquo;s Algorithm</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-python">GreedyMST(G):
    <span style="color: #dcaeea;">A</span> = []
    sort edges by increasing weight
    <span style="color: #51afef;">for</span> k = <span style="color: #da8548; font-weight: bold;">1</span>, ..., m:
        <span style="color: #51afef;">if</span> e_k does <span style="color: #51afef;">not</span> create a cycle <span style="color: #51afef;">in</span> A:
            append e_k to A
</pre>
</div>
</div>
<div id="outline-container-orgabbd721" class="outline-3">
<h3 id="orgabbd721"><span class="section-number-3">2.1.</span> Augmenting Sets without Cycles</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<b>Claim</b>: Let \(G\) be a connected graph and let \(A\) be a subset of the edges of \(G\).
If \((V, A)\) has no cycle and \(|A| < n - 1\), then one can find an edge \(e\) not in \(A\)
such that \(A \cup \{e\}\) still has no cycle.
</p>

<p>
<b>Proof</b>:
</p>
<ul class="org-ul">
<li>in any graph, \# vertices - \# connected components \(\le\) \# edges</li>
<li>for \((V, A)\), this gives \(n - c < n - 1\) so \(c > 1\)</li>
<li>take any edge on a path that connects two components</li>
</ul>
</div>
</div>
<div id="outline-container-org1e2c9b6" class="outline-3">
<h3 id="org1e2c9b6"><span class="section-number-3">2.2.</span> Properties of the Output</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<b>Claim</b>: If the output is \(A = [e_{1}, \dots, e_{r}]\) then \((V, A)\) is a spanning tree
\(r = n - 1\).
</p>

<p>
<b>Proof</b>:
</p>
<ul class="org-ul">
<li>\((V, A)\) has no cycle</li>
<li>suppose \((V,A)\) is not a spanning tree, then there exists an edge \(e\) not in A such
that \((V, A \cup \{e\})\) still has no cycle
<ul class="org-ul">
<li>for the case where \(w(e) < w(e_{1})\), this is impossible since \(e_{1}\) has the
smallest weight</li>
<li>for the case where \(w(e_{i}) < w(e) < w(e_{i+1})\), this is impossible since at
the moment we had inserted \(e_{i+1}\), we decided not to include \(e\) which means
that \(e\) created a loop with \(e_{1}, \dots, e_{i}\)</li>
<li>for the case where \(w(e_{r}) < w(e)\), this is impossible since if it was included
in \(A\) since there is no loop in \(A \cup \{e\}\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6203ecb" class="outline-3">
<h3 id="org6203ecb"><span class="section-number-3">2.3.</span> Exchanging Edges</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<b>Claim</b>: Let \((V, A)\) and \((V, T)\) be 2 spanning trees and let \(e\) be an edge in \(t\) but not in \(A\).
Then there is some edge \(e'\) in \(A\) but not in \(T\) such that \((V, T + e' - e)\) is still a spanning
tree. Further, \(e'\) is on the cycle that \(e\) creates in \(A\).
</p>

<p>
<b>Proof</b>:
</p>
<ul class="org-ul">
<li>consider \(e = \{v, w\}\)</li>
<li>\((V, A + e)\) contains a cycle \(c = v, w, \dots, v\)</li>
<li>removing \(e\) from \(T\) splits \((V, T - e)\) into two connected components \(T_{1}, T_{2}\)</li>
<li>\(c\) starts in \(T_{1}\), crosses over to \(T_{2}\), so it contains another edge \(e'\) between \(T_{2}\)
and \(T_{1}\)</li>
<li>\(e'\) is in \(A\) but not in \(T\)</li>
<li>\((V, T + e' - e)\) is a spanning tree</li>
</ul>
</div>
</div>
<div id="outline-container-orgef24e31" class="outline-3">
<h3 id="orgef24e31"><span class="section-number-3">2.4.</span> Correctness: Exchange Argument</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Let \(A\) be the output of the algorithm, \((V,T)\) be any spanning tree.
If \(T \ne A\), let \(e\) be an edge in \(T\) but not in \(A\). This means there is an edge \(e'\)
in \(A\) but not in \(T\) such that \((V, T + e' - e)\) is a spanning tree and \(e'\) is on the
cycle that \(e\) creates in \(A\).
</p>

<p>
During the algorithm, we considered \(e\) but rejected it because it created a cycle in \(A\).
All other elements in this cycle have smaller (or equal) weight, so \(w(e') \le w(e)\) and so
\(T' = T + e' - e\) has weight \(\le w(T)\) and one more common element with \(A\). This continues.
</p>
</div>
</div>
</div>
<div id="outline-container-org8c1bdbd" class="outline-2">
<h2 id="org8c1bdbd"><span class="section-number-2">3.</span> Data Structures for Kruskal&rsquo;s Algorithm</h2>
<div class="outline-text-2" id="text-3">
<p>
Operations possible on disjoint sets of vertices are:
</p>
<ul class="org-ul">
<li><b>find</b>: identify which set contains a given vertex</li>
<li><b>union</b>: replace 2 sets by their union</li>
</ul>
</div>
<div id="outline-container-org13fcbd2" class="outline-3">
<h3 id="org13fcbd2"><span class="section-number-3">3.1.</span> Implementation</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-python">GreedyMST_UnionFind(G):
    <span style="color: #dcaeea;">T</span> = []
    <span style="color: #dcaeea;">U</span> = {{v1}, ..., {vn}}
    sort edges by increasing weight
    <span style="color: #51afef;">for</span> k <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">1</span>, m):
        <span style="color: #51afef;">if</span> U.find(ek.<span style="color: #da8548; font-weight: bold;">1</span>) != U.find(ek.<span style="color: #da8548; font-weight: bold;">2</span>):
            U.union(U.find(ek.<span style="color: #da8548; font-weight: bold;">1</span>), U.find(ek.<span style="color: #da8548; font-weight: bold;">2</span>))
            append ek to T
</pre>
</div>
</div>
</div>
<div id="outline-container-org68dbc23" class="outline-3">
<h3 id="org68dbc23"><span class="section-number-3">3.2.</span> Linked List</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Uses an array of linked lists for \(U\).
</p>

<p>
To do find, add an array of indices where \(X[i]\) is the set that contains \(i\).
</p>

<p>
In the worst case for this, find is \(O(1)\) but union traverses one of the linked lists,
updates the corresponding entries of \(X\), and concatenates 2 linked lists,
so union worst case is \(\Theta(n)\).
</p>

<p>
This gives Kruskal&rsquo;s Algorithm to be \(O(m \log(m))\) in sorting edges, \(O(m)\) for find,
\(O(n)\) for union, and overall worst case \(O(m \log(m) + n^{2})\).
</p>
</div>
</div>
<div id="outline-container-org02ce4a6" class="outline-3">
<h3 id="org02ce4a6"><span class="section-number-3">3.3.</span> Simple Heuristics for Union</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org0d1af98" class="outline-4">
<h4 id="org0d1af98"><span class="section-number-4">3.3.1.</span> Modified Union</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
Each set in \(U\) keeps track of its size and only traverse the smaller list.
</p>

<p>
Also, add a pointer to the trail of the lists to concatenate in \(O(1)\).
</p>
</div>
</div>
<div id="outline-container-orge8ead98" class="outline-4">
<h4 id="orge8ead98"><span class="section-number-4">3.3.2.</span> Key Observation</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
Worst case for 1 union is still \(\Theta(n)\) but better total time:
</p>
<ul class="org-ul">
<li>for any given vertex \(v\), the size of the set containing \(v\) at least doubles when
we update \(X[v]\), so \(X[v]\) updated at most \(\log(n)\) times</li>
<li>so the total cost of union per vertex is \(O(\log(n))\)</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Arnav Gupta</p>
<p class="date">Created: 2024-02-29 Thu 12:51</p>
</div>
</body>
</html>
