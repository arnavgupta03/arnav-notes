#+title: Concurrency: Deadlock and Starvation
#+LATEX: \setlength\parindent{0pt}
#+STARTUP: latexpreview
#+author: Arnav Gupta

* Principles of Deadlock
Deadlock: permanent blocking of a set of processes that either compete
for system resources or communicate with each other.

No efficient solution exists in the general case.

Deadlock can be illustrated with a joint process diagram, which
illustrates the progress of two processes competing for two resources.
- if an execution path on a joint process diagram enters the fatal region,
  deadlock is inevitable

** Consumable Resources
Consumable resource: one that can be created and destroyed (ex. interrupts,
signals, messages, IO buffer info)

When such a resource is acquired by a consuming process, the resource
ceases to exist.

Can lead to deadlock, such as conflicting order of messages.

Common approaches to deal with deadlocks:
- *deadlock prevention*: disallow one of the three necessary conditions
  for deadlock occurrence (or prevent circular wait condition from
  happening)
- *deadlock avoidance*: do not grant a resource request if the allocation might lead to deadlock
- *deadlock detection*: grant resource requests when possible, but check
  for presence of deadlock and take action to recover

** Resource Allocation Grpahs
Resource allocation graph: directed graph that depicts a state of the system
of resources and processes, with each process and each resource represented
by a node, edges indicating requests for resources not yet granted
- each dot indicates one instance
- graph edge directed from a consumable resource node dot to a process
  indicates the process is the producer of the resource

** Conditions for Deadlock
Conditions of policy (1-3) must be present for a deadlock to be possible:
1. *mutual exclusion*: only one process may use a resource at a time, no process
   may access a resource unit that has been allocated by another process
2. *hold and wait*: process may hold allocated resources while awaiting assignment
   of other resources
3. *no preemption*: no resource can be forcibly removed from a process holding it
4. *circular wait*: closed chain of processes exists, such that each process
   holds at least one resource needed by the next process in the chain

Fatal region in joint progress diagram only exists if all of the first 3 conditions
above are met, otherwise no fatal region or deadlock occur.

Conditions 1-3 represent possibility of deadlock,
conditions 1-4 represent existence of deadlock.

* Deadlock Prevention
Strategy is to design a system such that the possibility of deadlock is excluded.

Two classes of deadlock prevention methods:
- *indirect method*: prevent the occurrence of 1 of the 3 necessary conditions
- *direct method*: prevent the occurence of a circular wait

** Mutual Exclusion
Mutual exclusion cannot be disallowed, since some resources require it.

** Hold and Wait
Can be prevented by requiring a process to request all required resources at once,
which is quite inefficient:
- a process may be held up with these resource requests even though it does not
  need them all
- allocating resources to this process denies them to other processes
- a process may not know in advance all resources it requires

** No Preemption
Can be prevented by:
- if a process holding certain resources is denied more, that process must release
  its original resources and request all necessary resources (including those it was
  denied) again
- if a process requests a resource held by another process, the OS may preempt the
  other process and require it to release its resources

Only practical to prevent when applied to resources whose state can be easily
saved and restored (like the processor).

** Circular Wait
Can be prevented by defining a linear ordering of resource types, where resources
can only be requested in the order specified.

Preventing this may be inefficient, slow processes and deny resource access.

* Deadlock Avoidance
Avoidance allows the 3 necessary conditions for deadlock, but makes choices
to assure that deadlock is never reached.
- allows more concurrency than prevention
- requires knowledge of future process resource requests

** Process Initiation Denial
Consider a system of $n$ processes and $m$ types of resources.

Let $R = (R_{1}, R_{2}, \dots, R_{m})$ be the total amount of
each resource in the system.
Let $V = (V_{1}, V_{2}, \dots, V_{m})$ be the total amount of
each resource not allocated to any process.

Let the claim $C$ be
$$C = \begin{pmatrix}
       C_{11} & C_{12} & \cdots & C_{1m} \\
       C_{21} & C_{22} & \cdots & C_{2m} \\
       \vdots & \vdots & \vdots & \vdots \\
       C_{n1} & C_{n2} & \cdots & C_{nm}
\end{pmatrix}$$
where $C_{ij}$ is the requirement of process $i$ for resource $j$.

Let the allocation $A$ be
$$A = \begin{pmatrix}
        A_{11} & A_{12} & \cdots & A_{1m} \\
        A_{21} & A_{22} & \cdots & A_{2m} \\
        \vdots & \vdots & \vdots & \vdots \\
        A_{n1} & A_{n2} & \cdots & A_{nm}
\end{pmatrix}$$
where $A_{ij}$ is the current allocation to process $i$ of resource $j$.

The following relationships hold:
1. All resources are either available or allocated.
    $$R_{j} = V_{j} + \sum_{i = 1}^{n} A_{ij}, \forall j$$
2. No process can claim more than the total amount of resources
    in the system.
    $$C_{ij} \le R_{j}, \forall i, j$$
3. No process is allocated more resources of any type than the process
    originally claimed to need.
    $$A_{ij} \le C_{j}, \forall i, j$$

Using these, a deadlock avoidance policy can be defined that refuses to start
a new process if resource requirements might lead to deadlock.
The policy is to only start a new process $P_{n+1}$ if
$$R_{j} \ge C_{(n+1)j} + \sum_{i = 1}^{n} C_{ij}, \forall j$$
which means to only start a process if the maximum claim of all
current processes plus the new process can be met.

** Resource Allocation Denial
Strategy of resource allocation denial is called banker's algorithm.

Consider a system with a fixed number of processes and a fixed number of resources.
The state of the system reflects the current allocation of resources to processes,
consisting of vectors $R$ and $V$ and matrices $C$ and $A$.
Safe state is when there is some sequence of resource allocations to processes
that does not result in deadlock.

To find if a state is safe, check if any process can be run to completion with
the resources available. For some process $i$, this requires
$$C_{ij} - A_{ij} \le V_{j}, \forall j$$
Once such a process is found, assume it runs to completion and make its resources
available. Begin again.

The deadlock aavoidance strategy is to ensure that the system is always in a
safe state. If some resource request will put the system in an unsafe state,
block the process until it is safe to grant the request, otherwise grant it.

Deadlock avoidance strategy does not predict deadlock with certainty,
it just anticipates the possibility and assures this possibility never occurs.

Deadlock avoidance has the advantage that it is not necessary to preempt and
rollback processes and is less restrictive than deadlock prevention.
Restrictions on its use are:
- maximum resource requirement for each process must be stated in advance
- processes under consideration must be independent (order of execution
  must be unconstrained by synchronization requirements)
- must be a fixed number of resources to allocate
- no process may exit while holding resources
